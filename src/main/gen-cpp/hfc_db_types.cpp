/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hfc_db_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace hfc_db {


Table::~Table() noexcept {
}

Table::Table() noexcept {
}

void Table::__set_rows(const std::vector<std::vector<std::string> > & val) {
  this->rows = val;
}
std::ostream& operator<<(std::ostream& out, const Table& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Table::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_rows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->rows.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              {
                this->rows[_i4].clear();
                uint32_t _size5;
                ::apache::thrift::protocol::TType _etype8;
                xfer += iprot->readListBegin(_etype8, _size5);
                this->rows[_i4].resize(_size5);
                uint32_t _i9;
                for (_i9 = 0; _i9 < _size5; ++_i9)
                {
                  xfer += iprot->readString(this->rows[_i4][_i9]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Table::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Table");

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rows.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter10;
    for (_iter10 = this->rows.begin(); _iter10 != this->rows.end(); ++_iter10)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter10).size()));
        std::vector<std::string> ::const_iterator _iter11;
        for (_iter11 = (*_iter10).begin(); _iter11 != (*_iter10).end(); ++_iter11)
        {
          xfer += oprot->writeString((*_iter11));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Table &a, Table &b) {
  using ::std::swap;
  swap(a.rows, b.rows);
}

bool Table::operator==(const Table & rhs) const
{
  if (!(rows == rhs.rows))
    return false;
  return true;
}

Table::Table(const Table& other12) {
  rows = other12.rows;
}
Table& Table::operator=(const Table& other13) {
  rows = other13.rows;
  return *this;
}
void Table::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Table(";
  out << "rows=" << to_string(rows);
  out << ")";
}


QueryResult::~QueryResult() noexcept {
}

QueryResult::QueryResult() noexcept {
}

void QueryResult::__set_variables(const std::vector<std::string> & val) {
  this->variables = val;
}

void QueryResult::__set_table(const Table& val) {
  this->table = val;
}
std::ostream& operator<<(std::ostream& out, const QueryResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t QueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_variables = false;
  bool isset_table = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->variables.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->variables.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readString(this->variables[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          isset_variables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          isset_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_variables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t QueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("QueryResult");

  xfer += oprot->writeFieldBegin("variables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->variables.size()));
    std::vector<std::string> ::const_iterator _iter19;
    for (_iter19 = this->variables.begin(); _iter19 != this->variables.end(); ++_iter19)
    {
      xfer += oprot->writeString((*_iter19));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->table.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryResult &a, QueryResult &b) {
  using ::std::swap;
  swap(a.variables, b.variables);
  swap(a.table, b.table);
}

bool QueryResult::operator==(const QueryResult & rhs) const
{
  if (!(variables == rhs.variables))
    return false;
  if (!(table == rhs.table))
    return false;
  return true;
}

QueryResult::QueryResult(const QueryResult& other20) {
  variables = other20.variables;
  table = other20.table;
}
QueryResult& QueryResult::operator=(const QueryResult& other21) {
  variables = other21.variables;
  table = other21.table;
  return *this;
}
void QueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "QueryResult(";
  out << "variables=" << to_string(variables);
  out << ", " << "table=" << to_string(table);
  out << ")";
}


PropInfo::~PropInfo() noexcept {
}

PropInfo::PropInfo() noexcept
   : type(0) {
}

void PropInfo::__set_type(const int32_t val) {
  this->type = val;
}

void PropInfo::__set_ranges(const std::vector<std::string> & val) {
  this->ranges = val;
}
std::ostream& operator<<(std::ostream& out, const PropInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PropInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_ranges = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ranges.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->ranges.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readString(this->ranges[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          isset_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ranges)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PropInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PropInfo");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ranges", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ranges.size()));
    std::vector<std::string> ::const_iterator _iter27;
    for (_iter27 = this->ranges.begin(); _iter27 != this->ranges.end(); ++_iter27)
    {
      xfer += oprot->writeString((*_iter27));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PropInfo &a, PropInfo &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.ranges, b.ranges);
}

bool PropInfo::operator==(const PropInfo & rhs) const
{
  if (!(type == rhs.type))
    return false;
  if (!(ranges == rhs.ranges))
    return false;
  return true;
}

PropInfo::PropInfo(const PropInfo& other28) {
  type = other28.type;
  ranges = other28.ranges;
}
PropInfo& PropInfo::operator=(const PropInfo& other29) {
  type = other29.type;
  ranges = other29.ranges;
  return *this;
}
void PropInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PropInfo(";
  out << "type=" << to_string(type);
  out << ", " << "ranges=" << to_string(ranges);
  out << ")";
}


QueryException::~QueryException() noexcept {
}

QueryException::QueryException() noexcept
   : why() {
}

void QueryException::__set_why(const std::string& val) {
  this->why = val;
}
std::ostream& operator<<(std::ostream& out, const QueryException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t QueryException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("QueryException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryException &a, QueryException &b) {
  using ::std::swap;
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

bool QueryException::operator==(const QueryException & rhs) const
{
  if (!(why == rhs.why))
    return false;
  return true;
}

QueryException::QueryException(const QueryException& other30) : TException() {
  why = other30.why;
  __isset = other30.__isset;
}
QueryException& QueryException::operator=(const QueryException& other31) {
  why = other31.why;
  __isset = other31.__isset;
  return *this;
}
void QueryException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "QueryException(";
  out << "why=" << to_string(why);
  out << ")";
}

const char* QueryException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: QueryException";
  }
}


TupleException::~TupleException() noexcept {
}

TupleException::TupleException() noexcept
   : why() {
}

void TupleException::__set_why(const std::string& val) {
  this->why = val;
}
std::ostream& operator<<(std::ostream& out, const TupleException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TupleException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TupleException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TupleException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TupleException &a, TupleException &b) {
  using ::std::swap;
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

bool TupleException::operator==(const TupleException & rhs) const
{
  if (!(why == rhs.why))
    return false;
  return true;
}

TupleException::TupleException(const TupleException& other32) : TException() {
  why = other32.why;
  __isset = other32.__isset;
}
TupleException& TupleException::operator=(const TupleException& other33) {
  why = other33.why;
  __isset = other33.__isset;
  return *this;
}
void TupleException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TupleException(";
  out << "why=" << to_string(why);
  out << ")";
}

const char* TupleException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TupleException";
  }
}


WrongFormatException::~WrongFormatException() noexcept {
}

WrongFormatException::WrongFormatException() noexcept
   : why() {
}

void WrongFormatException::__set_why(const std::string& val) {
  this->why = val;
}
std::ostream& operator<<(std::ostream& out, const WrongFormatException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WrongFormatException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WrongFormatException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WrongFormatException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WrongFormatException &a, WrongFormatException &b) {
  using ::std::swap;
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

bool WrongFormatException::operator==(const WrongFormatException & rhs) const
{
  if (!(why == rhs.why))
    return false;
  return true;
}

WrongFormatException::WrongFormatException(const WrongFormatException& other34) : TException() {
  why = other34.why;
  __isset = other34.__isset;
}
WrongFormatException& WrongFormatException::operator=(const WrongFormatException& other35) {
  why = other35.why;
  __isset = other35.__isset;
  return *this;
}
void WrongFormatException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WrongFormatException(";
  out << "why=" << to_string(why);
  out << ")";
}

const char* WrongFormatException::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: WrongFormatException";
  }
}

} // namespace
